# Generated by Django 5.0.4 on 2025-03-25 21:56

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = []

    operations = [
        migrations.RunSQL(
            """
            DROP FUNCTION IF EXISTS get_readable_notes;
            DROP FUNCTION IF EXISTS get_related_entry_paths_for_user;
            DROP FUNCTION IF EXISTS get_minimum_distances_for_user;
            DROP FUNCTION IF EXISTS get_paths_of_length_n_between_two_entries;
            DROP FUNCTION IF EXISTS find_all_paths;
            """
        ),
        migrations.RunSQL(
            """
            CREATE OR REPLACE FUNCTION find_all_paths(
                target_entry_id UUID,
                v BIT(2048),
                max_depth INT,
                targets UUID[],
                timerange_start TIMESTAMP,
                timerange_stop TIMESTAMP
            )
            RETURNS TABLE (
                path UUID[]
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                WITH RECURSIVE cte (
                    entry_id,
                    path_arr,
                    is_cycle
                ) AS (

                    -- 1) Base case: start with the target entry
                    SELECT
                        target_entry_id AS entry_id,
                        ARRAY[target_entry_id] AS path_arr,
                        FALSE AS is_cycle

                    UNION ALL

                    -- 2) Recursive case: follow the relation graph
                    SELECT
                        nr.dst_entry_id,
                        cte.path_arr || nr.dst_entry_id,
                        nr.dst_entry_id = ANY(cte.path_arr) AS is_cycle
                    FROM cte
                    JOIN entries_relation nr
                        ON nr.src_entry_id = cte.entry_id
                    WHERE
                        -- Only continue recursion if we haven't formed a cycle
                        NOT is_cycle
                        AND array_length(cte.path_arr, 1) < max_depth
                        AND nr.created_at BETWEEN timerange_start AND timerange_stop
                        -- Continue only along accessible paths
                        AND ((v | nr.access_vector) = v)
                )
                SELECT
                    cte.path_arr AS path
                FROM cte
                WHERE cte.entry_id = ANY(targets);
            END;
            $$;
            """
        ),
        migrations.RunSQL(
            sql="""
            CREATE MATERIALIZED VIEW node_map AS
            SELECT
                uuid,
                ROW_NUMBER() OVER ()::BIGINT AS id
            FROM (
                SELECT DISTINCT src AS uuid FROM edges
                UNION
                SELECT DISTINCT dst AS uuid FROM edges
            ) AS nodes;
            """,
            reverse_sql="DROP MATERIALIZED VIEW IF EXISTS node_map CASCADE;",
        ),
        migrations.RunSQL(
            sql="""
            CREATE MATERIALIZED VIEW edges_with_ids AS
            SELECT
                ROW_NUMBER() OVER ()::INTEGER AS edge_id,
                e.id,
                e.src,
                src_map.id AS src_id,
                e.dst,
                dst_map.id AS dst_id,
                e.access_vector,
                e.created_at,
                e.last_seen,
                e.age
            FROM edges e
            JOIN node_map src_map ON e.src = src_map.uuid
            JOIN node_map dst_map ON e.dst = dst_map.uuid;
            """,
            reverse_sql="DROP MATERIALIZED VIEW IF EXISTS edges_with_ids;",
        ),
        migrations.RunSQL(
            sql="""
            CREATE UNIQUE INDEX idx_node_map_uuid ON node_map(uuid);
            CREATE UNIQUE INDEX idx_node_map_id ON node_map(id);

            CREATE UNIQUE INDEX idx_edges_with_ids_edge_id ON edges_with_ids(edge_id);
            CREATE INDEX idx_edges_with_ids_src_id ON edges_with_ids(src_id);
            CREATE INDEX idx_edges_with_ids_dst_id ON edges_with_ids(dst_id);
            CREATE INDEX idx_edges_with_ids_uuid_id ON edges_with_ids(id);
            """,
            reverse_sql="""
            DROP INDEX IF EXISTS idx_node_map_uuid;
            DROP INDEX IF EXISTS idx_node_map_id;

            DROP INDEX IF EXISTS idx_edges_with_ids_edge_id;
            DROP INDEX IF EXISTS idx_edges_with_ids_src_id;
            DROP INDEX IF EXISTS idx_edges_with_ids_dst_id;
            DROP INDEX IF EXISTS idx_edges_with_ids_uuid_id;
            """,
        ),
    ]
