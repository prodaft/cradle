# Generated by Django 5.0.4 on 2025-03-08 01:12

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("notes", "0012_relation_access_vector"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP FUNCTION IF EXISTS get_readable_notes;
            DROP FUNCTION IF EXISTS get_related_entry_paths_for_user;
            DROP FUNCTION IF EXISTS get_minimum_distances_for_user;
            DROP FUNCTION IF EXISTS get_paths_of_length_n_between_two_entries;
            """
        ),
        migrations.RunSQL(
            """
            CREATE OR REPLACE FUNCTION get_related_entry_paths(
                target_entry_id UUID,
                v BIT(2048),
                max_depth INT,
                targets UUID[]
                -- ,timerange_start TIMESTAMP,
                -- timerange_stop TIMESTAMP
            )
            RETURNS TABLE (
                path UUID[]
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                WITH RECURSIVE cte (
                    entry_id,
                    path_arr,
                    is_cycle
                ) AS (

                    -- 1) Base case: start with the target entry
                    SELECT
                        target_entry_id AS entry_id,
                        ARRAY[target_entry_id] AS path_arr,
                        FALSE AS is_cycle,
                        0 AS depth_level,
                        TRUE AS can_access

                    UNION ALL

                    -- 2) Recursive case: follow the relation graph
                    SELECT
                        nr.dst_entry_id,
                        cte.path_arr || nr.dst_entry_id,
                        nr.dst_entry_id = ANY(cte.path_arr) AS is_cycle,
                    FROM cte
                    JOIN notes_relation nr
                        ON nr.src_entry_id = cte.entry_id
                    WHERE
                        -- Only continue recursion if we haven't formed a cycle
                        NOT is_cycle
                        AND array_length(cte.path_arr, 1) < max_depth
                        -- AND nr.created_at BETWEEN timerange_start AND timerange_stop
                        -- Continue only along accessible paths
                        AND (~v & nr.access_vector) = 0
                )
                SELECT
                    cte.path_arr AS path
                FROM cte
                WHERE cte.entry_id = ANY(targets);
            END;
            $$;
            """
        ),
        migrations.RunSQL(  # Clear the existing relations
            """
            CREATE OR REPLACE FUNCTION get_paths_of_length_n_between_two_entries(
                start_entry_id UUID,
                end_entry_id UUID,
                target_depth INT,
                v BIT(2048)
            )
            RETURNS TABLE (
                path UUID[],
                depth INT,
                can_access BOOLEAN
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                SELECT
                    cte.path,
                    cte.depth,
                    cte.can_access
                FROM get_related_entry_paths(
                    start_entry_id,
                    target_depth,
                    v
                ) cte
                WHERE
                    -- The last element in the path must be the end_entry_id
                    cte.path[array_length(cte.path, 1)] = end_entry_id
                    AND cte.depth <= target_depth;
            END;
            $$;
            """
        ),
        migrations.RunSQL(  # Clear the existing relations
            """
            CREATE OR REPLACE FUNCTION get_minimum_distances(
                target_entry_id UUID,
                v BIT(2048),
                max_depth INT
            )
            RETURNS TABLE (
                dst_entry UUID,
                can_access BOOLEAN,
                distance INT
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                WITH path_rows AS (
                    SELECT
                        cte.path[array_length(path, 1)] AS dst_entry,  -- Last object in the path
                        cte.depth,
                        cte.can_access
                    FROM get_related_entry_paths(
                        target_entry_id,
                        v,
                        max_depth
                    ) cte
                )
                SELECT
                  distances.dst_entry, MAX(CASE WHEN distances.can_access THEN 1 ELSE 0 END) = 1,
                  CASE
                      WHEN MAX(CASE WHEN distances.can_access THEN 1 ELSE 0 END) = 1 THEN
                          MIN(CASE WHEN distances.can_access THEN distances.min_distance ELSE NULL END)
                      ELSE
                          MIN(CASE WHEN NOT distances.can_access THEN distances.min_distance ELSE NULL END)
                  END AS distance
                  FROM (
                  SELECT
                      path_rows.dst_entry,
                      path_rows.can_access,
                      MIN(path_rows.depth) AS min_distance
                  FROM path_rows
                  GROUP BY path_rows.dst_entry, path_rows.can_access
                  ORDER BY min_distance) distances
                  GROUP BY distances.dst_entry;
            END;
            $$;
            """
        ),
    ]
