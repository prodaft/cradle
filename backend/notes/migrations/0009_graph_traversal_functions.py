# Generated by Django 5.0.4 on 2025-01-16 14:33

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("notes", "0008_remove_relation_unique_src_dst_note_and_more"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP FUNCTION IF EXISTS get_readable_notes;
            DROP FUNCTION IF EXISTS get_related_entry_paths_for_user;
            DROP FUNCTION IF EXISTS get_minimum_distances_for_user;
            DROP FUNCTION IF EXISTS get_paths_of_length_n_between_two_entries;
            """
        ),
        migrations.RunSQL(  # Clear the existing relations
            """
            CREATE OR REPLACE FUNCTION get_readable_notes(user_uuid UUID)
            RETURNS TABLE (note_id UUID)
            LANGUAGE plpgsql
            AS $$
            DECLARE
                is_super BOOLEAN := FALSE;
            BEGIN
                -- Otherwise, check if the user is a superuser in user_cradleuser
                SELECT is_superuser
                INTO is_super
                FROM user_cradleuser
                WHERE id = user_uuid;

                IF is_super THEN
                    -- If the user is superuser, return all notes
                    RETURN QUERY
                    SELECT DISTINCT ne.note_id
                    FROM notes_note_entries AS ne;
                ELSE
                    -- Otherwise, return only the notes for which this user has access
                    RETURN QUERY
                    SELECT DISTINCT ne.note_id
                    FROM notes_note_entries AS ne
                    JOIN entries_entry ee ON ne.entry_id = ee.id
                    JOIN entries_entryclass ec ON ee.entry_class_id = ec.subtype
                    RIGHT JOIN (
                        SELECT *
                        FROM access_access
                        WHERE user_id = user_uuid
                          AND access_type <> 'none'
                    ) a ON ne.entry_id = a.entity_id
                    WHERE ec.type = 'entity';
                END IF;
            END;
            $$;
            """
        ),
        migrations.RunSQL(  # Clear the existing relations
            """
            CREATE OR REPLACE FUNCTION get_related_entry_paths_for_user(
                target_entry_id UUID,
                user_id UUID,
                max_depth INT
            )
            RETURNS TABLE (
                path UUID[],
                depth INT,
                can_access BOOLEAN
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                WITH RECURSIVE cte (
                    entry_id,
                    path_arr,
                    is_cycle,
                    depth_level,
                    can_access
                ) AS (

                    /* 1) Non-recursive term (base case) */
                    SELECT
                        target_entry_id AS entry_id,
                        ARRAY[target_entry_id] AS path_arr,
                        FALSE AS is_cycle,
                        0 AS depth_level,
                        TRUE AS can_access

                    UNION ALL

                    /* 2) Recursive term */
                    SELECT
                        nr.dst_entry_id,
                        cte.path_arr || nr.dst_entry_id,
                        nr.dst_entry_id = ANY(cte.path_arr),
                        cte.depth_level + 1,

                        /*
                         * Compute new "can_access":
                         *  - remains TRUE only if the old path was accessible
                         *    AND the new relationship is accessible.
                         */
                        cte.can_access
                        AND (
                            nr.content_type_id <> 10
                            OR nr.object_id IN (
                                SELECT ne.note_id
                                FROM notes_note_entries ne
                                WHERE ne.note_id IN (
                                    SELECT rn.note_id
                                    FROM get_readable_notes(user_id) rn
                                )
                            )
                        )

                    FROM cte
                    JOIN notes_relation nr
                        ON nr.src_entry_id = cte.entry_id
                    WHERE
                        -- Only continue recursion if we've not exceeded max_depth
                        NOT cte.is_cycle
                        AND cte.depth_level < max_depth

                        -- Only generate more children from rows that are still "can_access = TRUE"
                        -- This ensures that once 'can_access' becomes FALSE, we do not go deeper.
                        AND cte.can_access = TRUE
                )
                SELECT
                    cte.path_arr AS path,
                    cte.depth_level AS depth,
                    cte.can_access
                FROM cte WHERE cte.is_cycle = FALSE;
            END;
            $$;
            """
        ),
        migrations.RunSQL(  # Clear the existing relations
            """
            CREATE OR REPLACE FUNCTION get_minimum_distances_for_user(
                target_entry_id UUID,
                user_id UUID,
                max_depth INT
            )
            RETURNS TABLE (
                dst_entry UUID,
                can_access BOOLEAN,
                distance INT
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                WITH path_rows AS (
                    SELECT
                        cte.path[array_length(path, 1)] AS dst_entry,  -- Last object in the path
                        cte.depth,
                        cte.can_access
                    FROM get_related_entry_paths_for_user(
                        target_entry_id,
                        user_id,
                        max_depth
                    ) cte
                )
                SELECT
                  distances.dst_entry, MAX(CASE WHEN distances.can_access THEN 1 ELSE 0 END) = 1,
                  CASE
                      WHEN MAX(CASE WHEN distances.can_access THEN 1 ELSE 0 END) = 1 THEN
                          MIN(CASE WHEN distances.can_access THEN distances.min_distance ELSE NULL END)
                      ELSE
                          MIN(CASE WHEN NOT distances.can_access THEN distances.min_distance ELSE NULL END)
                  END AS distance
                  FROM (
                  SELECT
                      path_rows.dst_entry,
                      path_rows.can_access,
                      MIN(path_rows.depth) AS min_distance
                  FROM path_rows
                  GROUP BY path_rows.dst_entry, path_rows.can_access
                  ORDER BY min_distance) distances
                  GROUP BY distances.dst_entry;
            END;
            $$;
            """
        ),
        migrations.RunSQL(  # Clear the existing relations
            """
            CREATE OR REPLACE FUNCTION get_paths_of_length_n_between_two_entries(
                user_id UUID,
                start_entry_id UUID,
                end_entry_id UUID,
                target_depth INT
            )
            RETURNS TABLE (
                path UUID[],
                depth INT,
                can_access BOOLEAN
            )
            LANGUAGE plpgsql
            AS
            $$
            BEGIN
                RETURN QUERY
                SELECT
                    cte.path,
                    cte.depth,
                    cte.can_access
                FROM get_related_entry_paths_for_user(
                    start_entry_id,
                    user_id,
                    target_depth
                ) cte
                WHERE
                    -- The last element in the path must be the end_entry_id
                    cte.path[array_length(cte.path, 1)] = end_entry_id
                    AND cte.depth <= target_depth;
            END;
            $$;
            """
        ),
    ]
