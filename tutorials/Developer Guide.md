# Table of Contents

-   [Introduction](#introduction)
    -   [Why Contribute?](#why-contribute)
    -   [Main Technologies](#main-technologies)
-   [File Structure](#file-structure)
-   [Quickstart Guide](#quickstart-guide)
    -   [Adding a File](#adding-a-file)
    -   [Creating the Component](#creating-the-component)
    -   [Adding It to the App Component](#adding-it-to-the-app-component)
        -   [HashRouter](#hashrouter)
        -   [AuthProvider](#authprovider)
        -   [PrivateRoute](#privateroute)
        -   [Home](#home)
        -   [Navbar & useNavbarContents](#navbar--usenavbarcontents)
        -   [Sidebar](#sidebar)
    -   [Testing Your Functionality](#testing-your-functionality)
-   [Possible Obstacles](#possible-obstacles)
    -   [API Base URL's](#api-base-urls)
    -   [Documenting with JSDoc](#documenting-with-jsdoc)
    -   [Importing Files & Jest](#importing-files--jest)
-   [Linting and Code Style](#linting-and-code-style)
    -   [ESLint](#eslint)
    -   [Prettier](#prettier)

# Introduction

Hi! This is the Developer Guide for CRADLE: A Hub For Managing Cyber Threat Intelligence Research Output. We are happy to have you here. This guide will take you through the reasons behind the application itself, some of its design choices and help you take on the task of contributing to it by adding new features.

## Why Contribute?

Why not? This is a project started by [🐦‍⬛PRODAFT](https://prodaft.com), with the hopes of making Cyber Threat Intelligence gathering a more streamlined process. CRADLE is designed to be a minimalistic and collaborative note-taking tool, with a focus on making a cyber analyst's job easier, specialized through resource management and an intuitive user experience.

By contributing to this project you would help us on this journey of making the internet a safer place, as well as having the possibility to learn a few new technologies, or to improve your portofolio.

## Main Technologies

-   📝 Markdown parsing using [marked.js](https://github.com/markedjs/marked/) and [CodeMirror](https://github.com/uiwjs/react-codemirror/)
-   📍 Graph visualization using [D3](https://d3js.org/)
-   😶‍🌫️ Cloud object storage using [MinIO](https://min.io/)
-   ⚛️ [React.js](https://react.dev), 🚀 [Electron](https://www.electronjs.org/) and ⚡ [Vite](https://vitejs.dev/) for developement (template: [Electron-Vite](https://electron-vite.org/))
-   🍃 [TailwindCSS](https://tailwindcss.com/) for styling
-   🃏 [Jest](https://jestjs.io/) and [Selenium](https://www.selenium.dev/) for testing
-   📚 [JSDoc](https://jsdoc.app/) for documentation
-   🧹 [ESLint](https://eslint.org/) and 🧼 [Prettier](https://prettier.io/) for clean code
-   🖼️ [Iconoir](https://iconoir.com/) for icons

# File Structure

The root contains config files, README's, licenses and so on.

After building the application, there will be an `out` folder in the root. This includes the files generated by the bundler.

After building the application, there will be an `out` folder in the root. This includes the files generated by the bundler.

Let's start with the root of the repository:

-   `src` contains the source code of the application. It will be discussed in more detail below.
-   `test` is a folder meant to hold end-to-end tests between the frontend and the backend applications.
-   `tutorials` are `.md` files like this one, referenced in the README and used in the generated JSDoc.
-   You will need a `.env`. Please follow the instructions in the README file to set up those environment variables. Also check the [Vite documentation](https://vitejs.dev/guide/env-and-mode) for details on how to name them and import them in your code.
-   Currently, all of the config files are in the root. Note that since this is an [Electron-Vite](https://electron-vite.org/) project, all of the configs are under `electron.vite.config.js`.
-   The `vite.config.js` file is used for for building the web page version of the application.

Now, the `src` folder:

-   `main` and `preload` are Electron-specific. These hold the code for starting the application and creating the window.
-   `renderer` is where the bulk of our application lies. It has the following architecture:
    -   `assets` are various resources, like images, svg's etc. These can be imported in files
    -   `components` holds the React components, the classes that display information to the user's screen. Each component has a folder belonging to it. This folder contains the component itself and its test class, with possible unit or integration tests.
    -   `hooks` are custom React hooks that control some state objects. See their definitions for more details. Please abide to the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) when writing custom hooks.
    -   `services` contain business logic. These communicate with the backend or other external API's. All [axios](https://axios-http.com/docs/intro) calls should go in here. There is a file under `services/axiosInstance` which contains two axios instances, one with authorization (`authAxios`) and one without (`noAuthAxios`). The former will automatically refresh JWT's when they expire and will have its default `Content-Type` headers as `application/json`. It is meant to be used to communicate with the backend API. The latter is a base axios instance, everything must be passed manually. See `axios.create()` to define more axios instances if needed.
    -   `styles` include the base [TailwindCSS](https://tailwindcss.com/) classes, along with a few custom classes. All custom classes must be defined in `styles/input.css`. After building, the application will use `styles/output.css` for its style classes.
    -   `utils` contain logic that was refactored out of other classes, often with the intent of being reused across multiple files.

# Quickstart Guide

## Adding a File

Let's walk through an example of adding a feature to the application. Let's assume we want to add a component that will display a random number from 1 to 100 to the user, which will be saved to the backend database if the user chooses to.

First, let's create the React component for this, in `src/renderer/src/components`:

We create a new folder in the `/components` folder named `RandomNumber`. Here, we create the component file `RandomNumber.jsx` and its test class `RandomNumber.test.jsx`. So, to access the component we need to go to `src/renderer/src/components/RandomNumber/RandomNumber.jsx`:

```
src
|-- main
|-- preload
|-- renderer
|   |-- src
|   |   |-- RandomNumber
|   |   |   |-- RandomNumber.jsx
|   |   |   `-- RandomNumber.test.jsx
|   |   |
|   |   |
|   |   |
```

This "folder-per-file" principle also applies for `hooks`, `services` and `utils`.

## Creating the Component

Now we can write the component itself. Let's begin with the utility function of generating a random number:

```js
/* /utils/numberUtils/numberUtils.js */

/**
 * ...
 */
const getRandomNumber = (max) => {
    return Math.floor(Math.random() * max) + 1;
};

export { getRandomNumber };
```

We could also make a custom hook that has a random number state and a setter for that state:

```js
/* /hooks/useRandomNumber/useRandomNumber.js */

import { useState } from 'react';
import { getRandomNumber } from '../../utils/numberUtils/numberUtils';

/**
 * ...
 */
const useRandomNumber = (max = 100) => {
    const [number, setNumber] = useState(getRandomNumber(max));

    const generateRandomNumber = () => {
        setNumber(getRandomNumber(max));
    };

    return [number, generateRandomNumber];
};

export default useRandomNumber;
```

We decided that at one point we might want to save this to the database, so let's define that service as well:

```js
/* /services/numberService/numberService.js */

import { authAxios } from '../axiosInstance/axiosInstance';

/**
 * ...
 */
const saveNumber = (number) => {
    return authAxios({
        // Note that authAxios has its base URL as the backend API's
        method: 'POST',
        url: '/numbers/',
    });
};

export { saveNumber };
```

```jsx
/* /components/RandomNumber/RandomNumber.jsx */

import React, { useState } from 'react';
import useRandomNumber from '../../hooks/useRandomNumber/useRandomNumber';
import { saveNumber } from '../../services/numberService/numberService';

/**
 * ...
 */
export default function RandomNumber() {
    const [randomNumber, generateRandomNumber] = useRandomNumber(100);

    // A function to save the number to the database
    const handleSaveNumber = () => {
        saveNumber(randomNumber)
            .then((response) => {
                // ...
                console.log('Number saved successfully!');
            })
            .catch((error) => {
                //...
                console.log(error);
            });
    };

    return (
        <div>
            <h2>Random Number: {randomNumber}</h2>
            <button className='btn btn-primary' onClick={handleSaveNumber}>
                Save This Number
            </button>
            <button className='btn btn-secondary' onClick={generateRandomNumber}>
                Generate New Number
            </button>
        </div>
    );
}
```

Notice the use of [RippleUI](https://www.ripple-ui.com/) style classes. These are used in many places throughout the project.

## Adding It to the App Component

_Now what?_

This new component needs to be added to the application for it to be usable. We move to `/renderer/src/App.jsx`, where the main component is defined:

```jsx
/* App.jsx */

import { Outlet, Route, Routes, HashRouter as Router } from 'react-router-dom';
import AuthProvider from './components/AuthProvider/AuthProvider.jsx';
// import ... from ...

/**
 * ...
 */
function App() {
    return (
        <HashRouter>
            <AuthProvider>
                <Routes>
                    <Route element={<PrivateRoute fallback={'/login'} />}>
                        {/* Add any routes for components that NEED authentication here */}
                        <Route path='/' element={<Home />}>
                            {/* Add any routes for components that keep the sidebar and navbar here */}
                            {/* ... */}
                            <Route
                                path='/random-number'
                                element={<RandomNumber />}
                            />{' '}
                            {/* <-- We will add it here. */}
                        </Route>
                        {/* Add any routes for components that DO NOT KEEP the sidebar and navbar here */}
                    </Route>
                    {/* Add any routes for components that DO NOT NEED authentication here */}
                    {/* ... */}
                    <Route path='*' element={<NotFound />} />
                </Routes>
            </AuthProvider>
        </HashRouter>
    );
}

export default App;
```

As you can see, it was added as a route inside the {@link Home} element. The following code will change the screen to our custom component:

```jsx
const navigate = useNavigate();
navigate('/random-number');
```

### HashRouter

`HashRouter` here is an instance of React Router's [HashRouter](https://reactrouter.com/en/main/router-components/hash-router). This wraps all components and it is used to allow navigation between pages with the `useNavigate()` hook. [See that documentation](https://reactrouter.com/en/main/hooks/use-navigate) for more info.

The reason for choosing `HashRouter`, although ReactRouter devs recommend against it was that it solved a few issues that we encountered. You can read [this](https://stackoverflow.com/questions/36505404/how-to-use-react-router-with-electron) and [this](https://berom0227.medium.com/why-using-hashrouter-in-electron-is-a-win-for-your-sanity-627a55ffbfbc) for more arguments for HashRouter when using Electron.

### AuthProvider

{@link AuthProvider} is a custom context provider that allows for client-side user authorization. This is defined in `src/renderer/components/AuthProvider/AuthProvider.jsx`. By calling the `useAuth()` custom hook in one of your components, you get access to the contents of the JWT and authentication utilities. **Keep in mind that these are only base64-decoded. The secret key is not used.**

```jsx
/* /components/MyComponent/MyComponent.jsx */

import useAuth from '../../hooks/useAuth/useAuth';
// import ... from ...

/**
 * ...
 */
export default function MyComponent() {
    // ...
    const auth = useAuth();

    console.log(auth.isAdmin); // false
    console.log(auth.access); // the access JWT. You probably don't need this since it is always added automatically
    console.log(auth.refresh); // the refresh JWT. You probably don't need this either.
    console.log(auth.isAuthenticated()); // true
    // See AuthProvider.jsx for more information.

    return (
        // ...
    )
}

```

### PrivateRoute

{@link PrivateRoute} verifies that `auth.isAuthenticated()` is true. Otherwise, it will navigate to the fallback, which for now is `'/login'`.

### Home

The {@link Home} component is the base component of the application. It contains a navbar and a sidebar, which will be discussed below. Inside it is an [Outlet](https://reactrouter.com/en/main/components/outlet), which allows for rendering other components. This is why some Routes are nested inside its Route.

### Navbar & useNavbarContents

The {@link Navbar} is a fixed element on the top of the screen. It is defined in {@link Home} and it allows the developer to add buttons to it dynamically, depending on what the {@link Home} page outlet renders. This can be done using the custom {@link useNavbarContents} hook. By default, the fleeting Notes button is always shown as the rightmost button.

Let's use our RandomNumber example and allow the user to save it from the navbar. This code will add a button to the left of the Fleeting Notes button, on the right part of the navbar.

```jsx
/* /components/RandomNumber/RandomNumber.jsx */

import React, { useState } from 'react';
import useRandomNumber from '../../hooks/useRandomNumber/useRandomNumber';
import { saveNumber } from '../../services/numberService/numberService';
import useNavbarContents from '../../hooks/useNavbarContents/useNavbarContents';

/**
 * ...
 */
export default function RandomNumber() {
    const [randomNumber, generateRandomNumber] = useRandomNumber(100);

    // A function to save the number to the database
    const handleSaveNumber = () => {
        saveNumber(randomNumber)
            .then((response) => {
                // ...
                console.log("Number saved successfully!");
            })
            .catch((error) => {
                //...
                console.log(error);
            });
    }

    useNavbarContents(
        <NavbarButton
            key={'save-random-number-btn'}
            icon={/* An icon element. It should be valid JSX syntax. */}
            text='Save This Number'
            onClick={handleSaveNumber}
            data-testid='save-random-number-btn'
        />,
        [/* add dependencies here */
            handleSaveNumber
        ]
    );

    return (
        <div>
            <h2>Random Number: {randomNumber}</h2>
            <button className='btn btn-secondary' onClick={generateRandomNumber}>Generate New Number</button>
        </div>
    );
};
```

We recommend you use a {@link NavbarButton}, {@link NavbarDropdown} or {@link NavbarSwitch}.

### Sidebar

The {@link Sidebar} component is the sidebar of the application. This is also always visible and it is part of the {@link Home} component. This contains buttons that navigate to different pages.

The Sidebar contains three {@link SidebarSection} elements. The first two ones are on the top, the second one having only admin-specific buttons. Let's add our RandomNumber here:

```jsx
/* /components/Sidebar/Sidebar.jsx */

// import ... from ...

/**
 * ...
 */
export default function Sidebar({ /* ... */ }) {
    const navigate = useNavigate();

    const randomNumberLocation = '/random-number';
    const handleRandomNumber = useCallback(() => {
        navigate(randomNumberLocation);
    }, [navigate]);

    // ...

    return (
        // ...
            <SidebarSection
                sectionType='header'
                height='fit'
                justify='start'
            >
                {/* ... the other buttons ... */}
                <SidebarItem
                    handleClick={handleRandomNumber}
                    icon={/* An icon element. It should be valid JSX syntax. */}
                    text='Random Number'
                    highlightedLocation={randomNumberLocation}
                />
            </SidebarSection>
        // ...
    )
}
```

## Testing Your Functionality

Most of our tests are unit and integration tests and use [Jest](https://jestjs.io/), but you are welome to write end-to-end tests with [Selenium](https://www.selenium.dev/). _Keep in mind that end-to-end tests should be skipped currently since the pipeline is not set up to run them._

Let's write a small test class for our initial standalone RandomNumber class:

```jsx
/* /components/RandomNumber/RandomNumber.jsx */

import React, { useState } from 'react';
import useRandomNumber from '../../hooks/useRandomNumber/useRandomNumber';
import { saveNumber } from '../../services/numberService/numberService';

/**
 * ...
 */
export default function RandomNumber() {
    const [randomNumber, generateRandomNumber] = useRandomNumber(100);

    // A function to save the number to the database
    const handleSaveNumber = () => {
        saveNumber(randomNumber)
            .then((response) => {
                // ...
                console.log("Number saved successfully!");
            })
            .catch((error) => {
                //...
                console.log(error);
            });
    }

    return (
        <div>
            <h2>Random Number: {randomNumber}</h2>
            <button
                className='btn btn-primary'
                onClick={handleSaveNumber}
                data-testid='save-random-number-btn' {/* Notice the addition of this test id */}
            >
                Save This Number
            </button>
            <button className='btn btn-secondary' onClick={generateRandomNumber}>Generate New Number</button>
        </div>
    );
};
```

---

```jsx
/* /components/RandomNumber/RandomNumber.test.jsx */

/**
 * @jest-environment jsdom
 */
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react';
import RandomNumber from './RandomNumber';
import * as numberService from '../../services/numberService/numberService';

// Mock the useRandomNumber hook
jest.mock('/hooks/useRandomNumber/useRandomNumber', () => ({
    __esModule: true,
    default: () => [42, jest.fn()],
}));

// Mock the saveNumber service function
jest.mock('/services/numberService/numberService', () => ({
    saveNumber: jest.fn(),
}));

describe('RandomNumber', () => {
    // ...

    it('calls saveNumber with the current number when the save button is clicked', async () => {
        numberService.saveNumber.mockResolvedValueOnce({
            message: 'Number saved successfully!',
        });

        const { getByTestId } = render(<RandomNumber />);
        const saveButton = getByTestId('save-random-number-btn');

        fireEvent.click(saveButton);

        await waitFor(() => expect(numberService.saveNumber).toHaveBeenCalledWith(42));
    });

    // ...
});
```

Of course, this is not the best example of a test. However, it does lay a good foundation and we hope it shows how we use Jest in our project.

_This class was not run so we do not guarantee its corectness. Please look at the existing test classes for concrete examples._

# Possible Obstacles

During the development process, some challenges were encountered. The most relevant ones will be presented here, such that they are not repeated.

## API Base URL's

If you are hosting the backend on a server who's domain contains a path (e.g. `localhost:8000/api`), keep that in mind when parsing certain URL's. Also, keep in mind that if the request URL does not end in '/', then the client will be redirected to the path that does. However, only the path of the request will be called.

For example, seding a `GET` request to `localhost:8000/api/users` will redirect to `localhost:8000/users/` (assuming that `VITE_API_BASE_URL = localhost:8000/api` in the `.env` file).

## Documenting with JSDoc

When writing documentation for your contribution, please note that (the current version) of JSDoc cannot parse TypeScript import syntax, for example:

```js
/**
 * ...
 * @param {import('../myfolder/myfile.js').MyType} myParam
 * ...
 */
```

However, the IntelliSense of some IDE's, like VSCode's, only works with this sytnax. **We recommend that you only write the name of the type that you defined, without importing it, so that it is able to be generated in the JSDoc file.**

Moreover, JSDoc cannot generate documentation for React elements which are defined as:

```jsx
/**
 * This is not enough!
 *
 * @param {Object} props
 * @param {MyType1} props.prop1
 * @param {MyType2} props.prop2
 * @returns {MyComponent}
 */
export default function MyComponent({ prop1, prop2 }) {
    // ...
}
```

These components **must** either be exported after they are defined, or be annotated with [@function](https://jsdoc.app/tags-function) and [@constructor](https://jsdoc.app/tags-class):

```jsx
/**
 * This will be generated correctly. We recommend this.
 *
 * @function MyComponent
 * @param {Object} props
 * @param {MyType1} props.prop1
 * @param {MyType2} props.prop2
 * @returns {MyComponent}
 * @constructor
 */
export default function MyComponent({ prop1, prop2 }) {
    // ...
}
```

## Importing Files & Jest

When testing, `jest` does not correctly transform files that are not `.js(x)`. If there is a file import that is making the tests fail, make sure that it is dealt with in `jest.config.js`.

Note: We were unable to import raw data from a file, for example:

```js
import template from 'mytemplate.html?raw';
```

# Linting and Code Style

## ESLint

For linting we use [ESLint](https://eslint.org/). Currently only a default configuration is being used, but the config file is available at the root of the project, at `eslint.config.mjs`.

To run:

```shell
npm run lint
```

## Prettier

For code styling we use [Prettier](https://prettier.io/) and its configuration file is available at the root of the project, at `.prettierrc`.

To run:

```shell
npm run prettier
```

# Additional Inquiries

If any other questions arise, feel free to open an issue or contact the developers of the project for more information.
