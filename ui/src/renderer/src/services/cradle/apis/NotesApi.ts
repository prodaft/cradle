/* tslint:disable */
/* eslint-disable */
/**
 * CRADLE
 * Threat Intelligence Knowledge Management
 *
 * The version of the OpenAPI document: 2.8.0 (2.8.0)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FileReferenceRequest,
  FileReferenceWithNoteRequest,
  NoteRetrieve,
  PaginatedFileReferenceWithNoteSerializerResponse,
  PaginatedNoteRetrieveWithLinksSerializerResponse,
  PaginatedSubGraphSerializerResponse,
  Snippet,
  UserRetrieveRequest,
} from '../models/index';
import {
    FileReferenceRequestFromJSON,
    FileReferenceRequestToJSON,
    FileReferenceWithNoteRequestFromJSON,
    FileReferenceWithNoteRequestToJSON,
    NoteRetrieveFromJSON,
    NoteRetrieveToJSON,
    PaginatedFileReferenceWithNoteSerializerResponseFromJSON,
    PaginatedFileReferenceWithNoteSerializerResponseToJSON,
    PaginatedNoteRetrieveWithLinksSerializerResponseFromJSON,
    PaginatedNoteRetrieveWithLinksSerializerResponseToJSON,
    PaginatedSubGraphSerializerResponseFromJSON,
    PaginatedSubGraphSerializerResponseToJSON,
    SnippetFromJSON,
    SnippetToJSON,
    UserRetrieveRequestFromJSON,
    UserRetrieveRequestToJSON,
} from '../models/index';

export interface NotesCreateRequest {
    publishable?: boolean;
    content?: string;
    files?: Array<FileReferenceRequest>;
}

export interface NotesDeleteRequest {
    noteId: string;
}

export interface NotesFilesRetrieveRequest {
    date?: string;
    keyword?: string;
    linkedTo?: string;
    linkedToExactMatch?: boolean;
    mimetype?: string;
    page?: number;
    pageSize?: number;
    references?: Array<string>;
    timestampGte?: string;
    timestampLte?: string;
}

export interface NotesGraphRetrieveRequest {
    noteId: string;
    page?: number;
    pageSize?: number;
}

export interface NotesListRequest {
    authorUsername?: string;
    content?: string;
    date?: string;
    page?: number;
    pageSize?: number;
    references?: Array<string>;
    timestampGte?: string;
    timestampLte?: string;
    truncate?: number;
}

export interface NotesRetrieveRequest {
    noteId: string;
    footnotes?: boolean;
}

export interface NotesSnippetsDestroyRequest {
    snippetId: string;
}

export interface NotesSnippetsPartialUpdateRequest {
    snippetId: string;
    name?: string;
    content?: string;
}

export interface NotesSnippetsRetrieveRequest {
    snippetId: string;
}

export interface NotesSnippetsUpdateRequest {
    snippetId: string;
    name: string;
    content: string;
}

export interface NotesSnippetsUserCreateRequest {
    userId: string;
    name: string;
    content: string;
}

export interface NotesSnippetsUserListRequest {
    userId: string;
}

export interface NotesUpdateRequest {
    noteId: string;
    content: string;
    author: UserRetrieveRequest;
    entries: Array<string>;
    editor: UserRetrieveRequest;
    files: Array<FileReferenceWithNoteRequest>;
    publishable?: boolean;
    status?: NotesUpdateStatusEnum;
    statusMessage?: string;
    statusTimestamp?: Date | null;
    title?: string;
    description?: string;
    metadata?: any | null;
    editTimestamp?: Date | null;
    lastLinked?: Date | null;
}

/**
 * 
 */
export class NotesApi extends runtime.BaseAPI {

    /**
     * Creates a new note. User must have read-write access to all referenced entities.
     * Create note
     */
    async notesCreateRaw(requestParameters: NotesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NoteRetrieve>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['publishable'] != null) {
            formParams.append('publishable', requestParameters['publishable'] as any);
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }

        if (requestParameters['files'] != null) {
            formParams.append('files', requestParameters['files']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }


        let urlPath = `/notes/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NoteRetrieveFromJSON(jsonValue));
    }

    /**
     * Creates a new note. User must have read-write access to all referenced entities.
     * Create note
     */
    async notesCreate(requestParameters: NotesCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NoteRetrieve> {
        const response = await this.notesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an existing note. User must have read-write access to all referenced entities.
     * Delete note
     */
    async notesDeleteRaw(requestParameters: NotesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['noteId'] == null) {
            throw new runtime.RequiredError(
                'noteId',
                'Required parameter "noteId" was null or undefined when calling notesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/{note_id}/`;
        urlPath = urlPath.replace(`{${"note_id"}}`, encodeURIComponent(String(requestParameters['noteId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deletes an existing note. User must have read-write access to all referenced entities.
     * Delete note
     */
    async notesDelete(requestParameters: NotesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.notesDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns paginated list of files that are linked to notes the user has access to. Can filter by references and other parameters. Results are ordered by note timestamp descending.
     * Get files from accessible notes
     */
    async notesFilesRetrieveRaw(requestParameters: NotesFilesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedFileReferenceWithNoteSerializerResponse>> {
        const queryParameters: any = {};

        if (requestParameters['date'] != null) {
            queryParameters['date'] = requestParameters['date'];
        }

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['linkedTo'] != null) {
            queryParameters['linked_to'] = requestParameters['linkedTo'];
        }

        if (requestParameters['linkedToExactMatch'] != null) {
            queryParameters['linked_to_exact_match'] = requestParameters['linkedToExactMatch'];
        }

        if (requestParameters['mimetype'] != null) {
            queryParameters['mimetype'] = requestParameters['mimetype'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['references'] != null) {
            queryParameters['references'] = requestParameters['references'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp_gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp_lte'] = requestParameters['timestampLte'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/files/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedFileReferenceWithNoteSerializerResponseFromJSON(jsonValue));
    }

    /**
     * Returns paginated list of files that are linked to notes the user has access to. Can filter by references and other parameters. Results are ordered by note timestamp descending.
     * Get files from accessible notes
     */
    async notesFilesRetrieve(requestParameters: NotesFilesRetrieveRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedFileReferenceWithNoteSerializerResponse> {
        const response = await this.notesFilesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns paginated list of files that are linked to notes the user has access to. Can filter by references and other parameters. Results are ordered by note timestamp descending.
     * Get subgraph formed by note
     */
    async notesGraphRetrieveRaw(requestParameters: NotesGraphRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSubGraphSerializerResponse>> {
        if (requestParameters['noteId'] == null) {
            throw new runtime.RequiredError(
                'noteId',
                'Required parameter "noteId" was null or undefined when calling notesGraphRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/{note_id}/graph`;
        urlPath = urlPath.replace(`{${"note_id"}}`, encodeURIComponent(String(requestParameters['noteId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSubGraphSerializerResponseFromJSON(jsonValue));
    }

    /**
     * Returns paginated list of files that are linked to notes the user has access to. Can filter by references and other parameters. Results are ordered by note timestamp descending.
     * Get subgraph formed by note
     */
    async notesGraphRetrieve(requestParameters: NotesGraphRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSubGraphSerializerResponse> {
        const response = await this.notesGraphRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns paginated list of notes that the user has access to. Can filter by references and other parameters. Results are ordered by timestamp descending.
     * Get accessible notes
     */
    async notesListRaw(requestParameters: NotesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedNoteRetrieveWithLinksSerializerResponse>> {
        const queryParameters: any = {};

        if (requestParameters['authorUsername'] != null) {
            queryParameters['author__username'] = requestParameters['authorUsername'];
        }

        if (requestParameters['content'] != null) {
            queryParameters['content'] = requestParameters['content'];
        }

        if (requestParameters['date'] != null) {
            queryParameters['date'] = requestParameters['date'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['references'] != null) {
            queryParameters['references'] = requestParameters['references'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp_gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp_lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['truncate'] != null) {
            queryParameters['truncate'] = requestParameters['truncate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedNoteRetrieveWithLinksSerializerResponseFromJSON(jsonValue));
    }

    /**
     * Returns paginated list of notes that the user has access to. Can filter by references and other parameters. Results are ordered by timestamp descending.
     * Get accessible notes
     */
    async notesList(requestParameters: NotesListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedNoteRetrieveWithLinksSerializerResponse> {
        const response = await this.notesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the full details of a specific note. User must have access to view the note. Can optionally include footnotes.
     * Get note details
     */
    async notesRetrieveRaw(requestParameters: NotesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NoteRetrieve>> {
        if (requestParameters['noteId'] == null) {
            throw new runtime.RequiredError(
                'noteId',
                'Required parameter "noteId" was null or undefined when calling notesRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['footnotes'] != null) {
            queryParameters['footnotes'] = requestParameters['footnotes'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/{note_id}/`;
        urlPath = urlPath.replace(`{${"note_id"}}`, encodeURIComponent(String(requestParameters['noteId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NoteRetrieveFromJSON(jsonValue));
    }

    /**
     * Returns the full details of a specific note. User must have access to view the note. Can optionally include footnotes.
     * Get note details
     */
    async notesRetrieve(requestParameters: NotesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NoteRetrieve> {
        const response = await this.notesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a specific snippet by ID.
     * Delete a snippet
     */
    async notesSnippetsDestroyRaw(requestParameters: NotesSnippetsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['snippetId'] == null) {
            throw new runtime.RequiredError(
                'snippetId',
                'Required parameter "snippetId" was null or undefined when calling notesSnippetsDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/snippets/{snippet_id}/`;
        urlPath = urlPath.replace(`{${"snippet_id"}}`, encodeURIComponent(String(requestParameters['snippetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific snippet by ID.
     * Delete a snippet
     */
    async notesSnippetsDestroy(requestParameters: NotesSnippetsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.notesSnippetsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Returns all snippets accessible to the current user (user\'s own snippets and system snippets).
     * List all accessible snippets
     */
    async notesSnippetsListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Snippet>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/snippets/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SnippetFromJSON));
    }

    /**
     * Returns all snippets accessible to the current user (user\'s own snippets and system snippets).
     * List all accessible snippets
     */
    async notesSnippetsList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Snippet>> {
        const response = await this.notesSnippetsListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Partially update a specific snippet by ID.
     * Partially update a snippet
     */
    async notesSnippetsPartialUpdateRaw(requestParameters: NotesSnippetsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Snippet>> {
        if (requestParameters['snippetId'] == null) {
            throw new runtime.RequiredError(
                'snippetId',
                'Required parameter "snippetId" was null or undefined when calling notesSnippetsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }


        let urlPath = `/notes/snippets/{snippet_id}/`;
        urlPath = urlPath.replace(`{${"snippet_id"}}`, encodeURIComponent(String(requestParameters['snippetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SnippetFromJSON(jsonValue));
    }

    /**
     * Partially update a specific snippet by ID.
     * Partially update a snippet
     */
    async notesSnippetsPartialUpdate(requestParameters: NotesSnippetsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Snippet> {
        const response = await this.notesSnippetsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get details of a specific snippet by ID.
     * Retrieve a snippet
     */
    async notesSnippetsRetrieveRaw(requestParameters: NotesSnippetsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Snippet>> {
        if (requestParameters['snippetId'] == null) {
            throw new runtime.RequiredError(
                'snippetId',
                'Required parameter "snippetId" was null or undefined when calling notesSnippetsRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/snippets/{snippet_id}/`;
        urlPath = urlPath.replace(`{${"snippet_id"}}`, encodeURIComponent(String(requestParameters['snippetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SnippetFromJSON(jsonValue));
    }

    /**
     * Get details of a specific snippet by ID.
     * Retrieve a snippet
     */
    async notesSnippetsRetrieve(requestParameters: NotesSnippetsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Snippet> {
        const response = await this.notesSnippetsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a specific snippet by ID.
     * Update a snippet
     */
    async notesSnippetsUpdateRaw(requestParameters: NotesSnippetsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Snippet>> {
        if (requestParameters['snippetId'] == null) {
            throw new runtime.RequiredError(
                'snippetId',
                'Required parameter "snippetId" was null or undefined when calling notesSnippetsUpdate().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling notesSnippetsUpdate().'
            );
        }

        if (requestParameters['content'] == null) {
            throw new runtime.RequiredError(
                'content',
                'Required parameter "content" was null or undefined when calling notesSnippetsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }


        let urlPath = `/notes/snippets/{snippet_id}/`;
        urlPath = urlPath.replace(`{${"snippet_id"}}`, encodeURIComponent(String(requestParameters['snippetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SnippetFromJSON(jsonValue));
    }

    /**
     * Update a specific snippet by ID.
     * Update a snippet
     */
    async notesSnippetsUpdate(requestParameters: NotesSnippetsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Snippet> {
        const response = await this.notesSnippetsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new snippet for the specified user. Use \'null\' as user_id for system snippets.
     * Create snippet for user or system
     */
    async notesSnippetsUserCreateRaw(requestParameters: NotesSnippetsUserCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Snippet>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling notesSnippetsUserCreate().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling notesSnippetsUserCreate().'
            );
        }

        if (requestParameters['content'] == null) {
            throw new runtime.RequiredError(
                'content',
                'Required parameter "content" was null or undefined when calling notesSnippetsUserCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }


        let urlPath = `/notes/snippets/user/{user_id}/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SnippetFromJSON(jsonValue));
    }

    /**
     * Creates a new snippet for the specified user. Use \'null\' as user_id for system snippets.
     * Create snippet for user or system
     */
    async notesSnippetsUserCreate(requestParameters: NotesSnippetsUserCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Snippet> {
        const response = await this.notesSnippetsUserCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all snippets owned by the specified user. Use \'null\' as user_id for system snippets.
     * List snippets for user or system
     */
    async notesSnippetsUserListRaw(requestParameters: NotesSnippetsUserListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Snippet>>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling notesSnippetsUserList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/notes/snippets/user/{user_id}/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SnippetFromJSON));
    }

    /**
     * Returns all snippets owned by the specified user. Use \'null\' as user_id for system snippets.
     * List snippets for user or system
     */
    async notesSnippetsUserList(requestParameters: NotesSnippetsUserListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Snippet>> {
        const response = await this.notesSnippetsUserListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing note. User must have read-write access to referenced entities.
     * Update note
     */
    async notesUpdateRaw(requestParameters: NotesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NoteRetrieve>> {
        if (requestParameters['noteId'] == null) {
            throw new runtime.RequiredError(
                'noteId',
                'Required parameter "noteId" was null or undefined when calling notesUpdate().'
            );
        }

        if (requestParameters['content'] == null) {
            throw new runtime.RequiredError(
                'content',
                'Required parameter "content" was null or undefined when calling notesUpdate().'
            );
        }

        if (requestParameters['author'] == null) {
            throw new runtime.RequiredError(
                'author',
                'Required parameter "author" was null or undefined when calling notesUpdate().'
            );
        }

        if (requestParameters['entries'] == null) {
            throw new runtime.RequiredError(
                'entries',
                'Required parameter "entries" was null or undefined when calling notesUpdate().'
            );
        }

        if (requestParameters['editor'] == null) {
            throw new runtime.RequiredError(
                'editor',
                'Required parameter "editor" was null or undefined when calling notesUpdate().'
            );
        }

        if (requestParameters['files'] == null) {
            throw new runtime.RequiredError(
                'files',
                'Required parameter "files" was null or undefined when calling notesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['publishable'] != null) {
            formParams.append('publishable', requestParameters['publishable'] as any);
        }

        if (requestParameters['status'] != null) {
            formParams.append('status', requestParameters['status'] as any);
        }

        if (requestParameters['statusMessage'] != null) {
            formParams.append('status_message', requestParameters['statusMessage'] as any);
        }

        if (requestParameters['statusTimestamp'] != null) {
            formParams.append('status_timestamp', (requestParameters['statusTimestamp'] as any).toISOString());
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }

        if (requestParameters['title'] != null) {
            formParams.append('title', requestParameters['title'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['metadata'] != null) {
            formParams.append('metadata', new Blob([JSON.stringify(NoteRetrieveToJSON(requestParameters['metadata']))], { type: "application/json", }));
                    }

        if (requestParameters['author'] != null) {
            formParams.append('author', new Blob([JSON.stringify(NoteRetrieveToJSON(requestParameters['author']))], { type: "application/json", }));
                    }

        if (requestParameters['entries'] != null) {
            formParams.append('entries', requestParameters['entries']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['editTimestamp'] != null) {
            formParams.append('edit_timestamp', (requestParameters['editTimestamp'] as any).toISOString());
        }

        if (requestParameters['editor'] != null) {
            formParams.append('editor', new Blob([JSON.stringify(NoteRetrieveToJSON(requestParameters['editor']))], { type: "application/json", }));
                    }

        if (requestParameters['lastLinked'] != null) {
            formParams.append('last_linked', (requestParameters['lastLinked'] as any).toISOString());
        }

        if (requestParameters['files'] != null) {
            formParams.append('files', requestParameters['files']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }


        let urlPath = `/notes/{note_id}/`;
        urlPath = urlPath.replace(`{${"note_id"}}`, encodeURIComponent(String(requestParameters['noteId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NoteRetrieveFromJSON(jsonValue));
    }

    /**
     * Updates an existing note. User must have read-write access to referenced entities.
     * Update note
     */
    async notesUpdate(requestParameters: NotesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NoteRetrieve> {
        const response = await this.notesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const NotesUpdateStatusEnum = {
    Healthy: 'healthy',
    Processing: 'processing',
    Warning: 'warning',
    Invalid: 'invalid'
} as const;
export type NotesUpdateStatusEnum = typeof NotesUpdateStatusEnum[keyof typeof NotesUpdateStatusEnum];
