/* tslint:disable */
/* eslint-disable */
/**
 * CRADLE
 * Threat Intelligence Knowledge Management
 *
 * The version of the OpenAPI document: 2.7.1 (2.7.1)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIKeyResponse,
  ChangePasswordResponse,
  DefaultNoteTemplateResponse,
  TokenObtainPair,
  TokenRefresh,
  UserManageResponse,
  UserRetrieve,
} from '../models/index';
import {
    APIKeyResponseFromJSON,
    APIKeyResponseToJSON,
    ChangePasswordResponseFromJSON,
    ChangePasswordResponseToJSON,
    DefaultNoteTemplateResponseFromJSON,
    DefaultNoteTemplateResponseToJSON,
    TokenObtainPairFromJSON,
    TokenObtainPairToJSON,
    TokenRefreshFromJSON,
    TokenRefreshToJSON,
    UserManageResponseFromJSON,
    UserManageResponseToJSON,
    UserRetrieveFromJSON,
    UserRetrieveToJSON,
} from '../models/index';

export interface Users2faDisableCreateRequest {
    token: string;
}

export interface Users2faEnableCreateRequest {
    token: string;
}

export interface Users2faVerifyCreateRequest {
    token: string;
}

export interface UsersApikeyCreateRequest {
    userId: string;
}

export interface UsersChangePasswordCreateRequest {
    oldPassword: string;
    newPassword: string;
}

export interface UsersCreateRequest {
    username: string;
    email: string;
    password: string;
    catalystApiKey?: string | null;
    vtApiKey?: string | null;
    vimMode?: boolean;
}

export interface UsersDefaultNoteTemplateCreateRequest {
    userId: string;
    template: string;
}

export interface UsersDefaultNoteTemplateRetrieveRequest {
    userId: string;
}

export interface UsersDestroyRequest {
    userId: string;
}

export interface UsersEmailConfirmCreateRequest {
    token: string;
}

export interface UsersLoginCreateRequest {
    username: string;
    password: string;
}

export interface UsersManageRetrieveRequest {
    actionName: string;
    userId: string;
}

export interface UsersRefreshCreateRequest {
    refresh: string;
}

export interface UsersResetPasswordCreateRequest {
    email?: string;
    username?: string;
}

export interface UsersResetPasswordUpdateRequest {
    email?: string;
    username?: string;
}

export interface UsersRetrieveRequest {
    userId: string;
}

export interface UsersUpdateRequest {
    userId: string;
    username: string;
    email: string;
    role?: UsersUpdateRoleEnum;
    twoFactorEnabled?: boolean;
    isActive?: boolean;
    vimMode?: boolean;
    emailConfirmed?: boolean;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * Disables 2FA for the user
     * Disable 2FA
     */
    async users2faDisableCreateRaw(requestParameters: Users2faDisableCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling users2faDisableCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['token'] != null) {
            formParams.append('token', requestParameters['token'] as any);
        }


        let urlPath = `/users/2fa/disable/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Disables 2FA for the user
     * Disable 2FA
     */
    async users2faDisableCreate(requestParameters: Users2faDisableCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.users2faDisableCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Initiates 2FA setup for the user and returns a QR code URL
     * Enable 2FA
     */
    async users2faEnableCreateRaw(requestParameters: Users2faEnableCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling users2faEnableCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['token'] != null) {
            formParams.append('token', requestParameters['token'] as any);
        }


        let urlPath = `/users/2fa/enable/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Initiates 2FA setup for the user and returns a QR code URL
     * Enable 2FA
     */
    async users2faEnableCreate(requestParameters: Users2faEnableCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.users2faEnableCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verifies the 2FA token and completes the setup
     * Verify 2FA Setup
     */
    async users2faVerifyCreateRaw(requestParameters: Users2faVerifyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling users2faVerifyCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['token'] != null) {
            formParams.append('token', requestParameters['token'] as any);
        }


        let urlPath = `/users/2fa/verify/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Verifies the 2FA token and completes the setup
     * Verify 2FA Setup
     */
    async users2faVerifyCreate(requestParameters: Users2faVerifyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.users2faVerifyCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates a new API key for the specified user. Users can onlygenerate keys for themselves, or admins can generate keys for non-admin users.
     * Generate API key
     */
    async usersApikeyCreateRaw(requestParameters: UsersApikeyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<APIKeyResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersApikeyCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/users/{user_id}/apikey`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => APIKeyResponseFromJSON(jsonValue));
    }

    /**
     * Generates a new API key for the specified user. Users can onlygenerate keys for themselves, or admins can generate keys for non-admin users.
     * Generate API key
     */
    async usersApikeyCreate(requestParameters: UsersApikeyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<APIKeyResponse> {
        const response = await this.usersApikeyCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows authenticated users to change their password by providing their old password and a new password.
     * Change Password
     */
    async usersChangePasswordCreateRaw(requestParameters: UsersChangePasswordCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangePasswordResponse>> {
        if (requestParameters['oldPassword'] == null) {
            throw new runtime.RequiredError(
                'oldPassword',
                'Required parameter "oldPassword" was null or undefined when calling usersChangePasswordCreate().'
            );
        }

        if (requestParameters['newPassword'] == null) {
            throw new runtime.RequiredError(
                'newPassword',
                'Required parameter "newPassword" was null or undefined when calling usersChangePasswordCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['oldPassword'] != null) {
            formParams.append('old_password', requestParameters['oldPassword'] as any);
        }

        if (requestParameters['newPassword'] != null) {
            formParams.append('new_password', requestParameters['newPassword'] as any);
        }


        let urlPath = `/users/change_password/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangePasswordResponseFromJSON(jsonValue));
    }

    /**
     * Allows authenticated users to change their password by providing their old password and a new password.
     * Change Password
     */
    async usersChangePasswordCreate(requestParameters: UsersChangePasswordCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangePasswordResponse> {
        const response = await this.usersChangePasswordCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new user account. Available to unauthenticated users.
     * Create user
     */
    async usersCreateRaw(requestParameters: UsersCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling usersCreate().'
            );
        }

        if (requestParameters['email'] == null) {
            throw new runtime.RequiredError(
                'email',
                'Required parameter "email" was null or undefined when calling usersCreate().'
            );
        }

        if (requestParameters['password'] == null) {
            throw new runtime.RequiredError(
                'password',
                'Required parameter "password" was null or undefined when calling usersCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['username'] != null) {
            formParams.append('username', requestParameters['username'] as any);
        }

        if (requestParameters['email'] != null) {
            formParams.append('email', requestParameters['email'] as any);
        }

        if (requestParameters['password'] != null) {
            formParams.append('password', requestParameters['password'] as any);
        }

        if (requestParameters['catalystApiKey'] != null) {
            formParams.append('catalyst_api_key', requestParameters['catalystApiKey'] as any);
        }

        if (requestParameters['vtApiKey'] != null) {
            formParams.append('vt_api_key', requestParameters['vtApiKey'] as any);
        }

        if (requestParameters['vimMode'] != null) {
            formParams.append('vim_mode', requestParameters['vimMode'] as any);
        }


        let urlPath = `/users/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Creates a new user account. Available to unauthenticated users.
     * Create user
     */
    async usersCreate(requestParameters: UsersCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.usersCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a user\'s default note template. Users can only update their own template.
     * Update default note template
     */
    async usersDefaultNoteTemplateCreateRaw(requestParameters: UsersDefaultNoteTemplateCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefaultNoteTemplateResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersDefaultNoteTemplateCreate().'
            );
        }

        if (requestParameters['template'] == null) {
            throw new runtime.RequiredError(
                'template',
                'Required parameter "template" was null or undefined when calling usersDefaultNoteTemplateCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['template'] != null) {
            formParams.append('template', requestParameters['template'] as any);
        }


        let urlPath = `/users/{user_id}/default_note_template/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultNoteTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Updates a user\'s default note template. Users can only update their own template.
     * Update default note template
     */
    async usersDefaultNoteTemplateCreate(requestParameters: UsersDefaultNoteTemplateCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefaultNoteTemplateResponse> {
        const response = await this.usersDefaultNoteTemplateCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the user\'s default note template. Users can only retrieve their own template.
     * Get default note template
     */
    async usersDefaultNoteTemplateRetrieveRaw(requestParameters: UsersDefaultNoteTemplateRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefaultNoteTemplateResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersDefaultNoteTemplateRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/users/{user_id}/default_note_template/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultNoteTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Returns the user\'s default note template. Users can only retrieve their own template.
     * Get default note template
     */
    async usersDefaultNoteTemplateRetrieve(requestParameters: UsersDefaultNoteTemplateRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefaultNoteTemplateResponse> {
        const response = await this.usersDefaultNoteTemplateRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async usersDestroyRaw(requestParameters: UsersDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/users/{user_id}/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async usersDestroy(requestParameters: UsersDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.usersDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Confirms a user\'s email using the token sent to their email address.
     * Email confirmation
     */
    async usersEmailConfirmCreateRaw(requestParameters: UsersEmailConfirmCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling usersEmailConfirmCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['token'] != null) {
            formParams.append('token', requestParameters['token'] as any);
        }


        let urlPath = `/users/email_confirm/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Confirms a user\'s email using the token sent to their email address.
     * Email confirmation
     */
    async usersEmailConfirmCreate(requestParameters: UsersEmailConfirmCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.usersEmailConfirmCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all users. Only available to admin users.
     * List users
     */
    async usersListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserRetrieve>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/users/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserRetrieveFromJSON));
    }

    /**
     * Returns a list of all users. Only available to admin users.
     * List users
     */
    async usersList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserRetrieve>> {
        const response = await this.usersListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Obtain a new pair of access and refresh tokens by providing valid user credentials.
     * Obtain JWT Pair
     */
    async usersLoginCreateRaw(requestParameters: UsersLoginCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenObtainPair>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling usersLoginCreate().'
            );
        }

        if (requestParameters['password'] == null) {
            throw new runtime.RequiredError(
                'password',
                'Required parameter "password" was null or undefined when calling usersLoginCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['username'] != null) {
            formParams.append('username', requestParameters['username'] as any);
        }

        if (requestParameters['password'] != null) {
            formParams.append('password', requestParameters['password'] as any);
        }


        let urlPath = `/users/login/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenObtainPairFromJSON(jsonValue));
    }

    /**
     * Obtain a new pair of access and refresh tokens by providing valid user credentials.
     * Obtain JWT Pair
     */
    async usersLoginCreate(requestParameters: UsersLoginCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenObtainPair> {
        const response = await this.usersLoginCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform various admin actions on a user account. Available actions: simulate, send_email_confirmation, password_reset_email
     * Manage user actions
     */
    async usersManageRetrieveRaw(requestParameters: UsersManageRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserManageResponse>> {
        if (requestParameters['actionName'] == null) {
            throw new runtime.RequiredError(
                'actionName',
                'Required parameter "actionName" was null or undefined when calling usersManageRetrieve().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersManageRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/users/{user_id}/manage/{action_name}`;
        urlPath = urlPath.replace(`{${"action_name"}}`, encodeURIComponent(String(requestParameters['actionName'])));
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserManageResponseFromJSON(jsonValue));
    }

    /**
     * Perform various admin actions on a user account. Available actions: simulate, send_email_confirmation, password_reset_email
     * Manage user actions
     */
    async usersManageRetrieve(requestParameters: UsersManageRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserManageResponse> {
        const response = await this.usersManageRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refresh the access token using a valid refresh token.
     * Refresh Access Token
     */
    async usersRefreshCreateRaw(requestParameters: UsersRefreshCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenRefresh>> {
        if (requestParameters['refresh'] == null) {
            throw new runtime.RequiredError(
                'refresh',
                'Required parameter "refresh" was null or undefined when calling usersRefreshCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['refresh'] != null) {
            formParams.append('refresh', requestParameters['refresh'] as any);
        }


        let urlPath = `/users/refresh/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenRefreshFromJSON(jsonValue));
    }

    /**
     * Refresh the access token using a valid refresh token.
     * Refresh Access Token
     */
    async usersRefreshCreate(requestParameters: UsersRefreshCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenRefresh> {
        const response = await this.usersRefreshCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends a password reset email to the user. Requires either email or username.
     * Request password reset
     */
    async usersResetPasswordCreateRaw(requestParameters: UsersResetPasswordCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['email'] != null) {
            formParams.append('email', requestParameters['email'] as any);
        }

        if (requestParameters['username'] != null) {
            formParams.append('username', requestParameters['username'] as any);
        }


        let urlPath = `/users/reset_password/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Sends a password reset email to the user. Requires either email or username.
     * Request password reset
     */
    async usersResetPasswordCreate(requestParameters: UsersResetPasswordCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.usersResetPasswordCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resets user password using a valid reset token and new password.
     * Reset password with token
     */
    async usersResetPasswordUpdateRaw(requestParameters: UsersResetPasswordUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['email'] != null) {
            formParams.append('email', requestParameters['email'] as any);
        }

        if (requestParameters['username'] != null) {
            formParams.append('username', requestParameters['username'] as any);
        }


        let urlPath = `/users/reset_password/`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Resets user password using a valid reset token and new password.
     * Reset password with token
     */
    async usersResetPasswordUpdate(requestParameters: UsersResetPasswordUpdateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.usersResetPasswordUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns details of a specific user. Regular users can only access their own details. Admin users can access details of non-admin users.
     * Get user details
     */
    async usersRetrieveRaw(requestParameters: UsersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRetrieve>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/users/{user_id}/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRetrieveFromJSON(jsonValue));
    }

    /**
     * Returns details of a specific user. Regular users can only access their own details. Admin users can access details of non-admin users.
     * Get user details
     */
    async usersRetrieve(requestParameters: UsersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRetrieve> {
        const response = await this.usersRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates details of a specific user. Regular users can only update their own details. Admin users can update details of non-admin users.
     * Update user details
     */
    async usersUpdateRaw(requestParameters: UsersUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRetrieve>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usersUpdate().'
            );
        }

        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling usersUpdate().'
            );
        }

        if (requestParameters['email'] == null) {
            throw new runtime.RequiredError(
                'email',
                'Required parameter "email" was null or undefined when calling usersUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['username'] != null) {
            formParams.append('username', requestParameters['username'] as any);
        }

        if (requestParameters['email'] != null) {
            formParams.append('email', requestParameters['email'] as any);
        }

        if (requestParameters['role'] != null) {
            formParams.append('role', requestParameters['role'] as any);
        }

        if (requestParameters['twoFactorEnabled'] != null) {
            formParams.append('two_factor_enabled', requestParameters['twoFactorEnabled'] as any);
        }

        if (requestParameters['isActive'] != null) {
            formParams.append('is_active', requestParameters['isActive'] as any);
        }

        if (requestParameters['vimMode'] != null) {
            formParams.append('vim_mode', requestParameters['vimMode'] as any);
        }

        if (requestParameters['emailConfirmed'] != null) {
            formParams.append('email_confirmed', requestParameters['emailConfirmed'] as any);
        }


        let urlPath = `/users/{user_id}/`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRetrieveFromJSON(jsonValue));
    }

    /**
     * Updates details of a specific user. Regular users can only update their own details. Admin users can update details of non-admin users.
     * Update user details
     */
    async usersUpdate(requestParameters: UsersUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRetrieve> {
        const response = await this.usersUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const UsersUpdateRoleEnum = {
    Admin: 'admin',
    Manager: 'manager',
    Entrymanager: 'entrymanager',
    Author: 'author'
} as const;
export type UsersUpdateRoleEnum = typeof UsersUpdateRoleEnum[keyof typeof UsersUpdateRoleEnum];
