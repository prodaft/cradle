/* tslint:disable */
/* eslint-disable */
/**
 * CRADLE
 * Threat Intelligence Knowledge Management
 *
 * The version of the OpenAPI document: 2.8.0 (2.8.0)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  EnricherList,
  EnricherResponse,
  Entity,
  Entry,
  EntryClass,
  EntryResponse,
  NextNameResponse,
  PaginatedRelationSerializerResponse,
} from '../models/index';
import {
    EnricherListFromJSON,
    EnricherListToJSON,
    EnricherResponseFromJSON,
    EnricherResponseToJSON,
    EntityFromJSON,
    EntityToJSON,
    EntryFromJSON,
    EntryToJSON,
    EntryClassFromJSON,
    EntryClassToJSON,
    EntryResponseFromJSON,
    EntryResponseToJSON,
    NextNameResponseFromJSON,
    NextNameResponseToJSON,
    PaginatedRelationSerializerResponseFromJSON,
    PaginatedRelationSerializerResponseToJSON,
} from '../models/index';

export interface EntitiesCreateRequest {
    name: string;
    description?: string | null;
    aliases?: Array<number>;
}

export interface EntitiesDestroyRequest {
    entityId: string;
}

export interface EntitiesRetrieveRequest {
    entityId: string;
}

export interface EntitiesUpdateRequest {
    entityId: string;
    name: string;
    description?: string | null;
    aliases?: Array<number>;
}

export interface EntriesEntriesCreateRequest {
    name: string;
    subtype: string;
}

export interface EntriesEntriesEnrichCreateRequest {
    entryId: string;
    enricher: number;
}

export interface EntriesEntriesEnrichListRequest {
    entryId: string;
}

export interface EntriesEntriesRetrieveRequest {
    id: string;
}

export interface EntriesNextNameRetrieveRequest {
    classSubtype: string;
}

export interface EntriesRelationsDestroyRequest {
    relationId: string;
}

export interface EntriesRelationsRetrieveRequest {
    relates: Array<number>;
}

export interface EntryClassesCreateRequest {
    type: EntryClassesCreateTypeEnum;
    subtype: string;
    format: string | null;
    description?: string | null;
    generativeRegex?: string;
    regex?: string;
    options?: string;
    prefix?: string;
    color?: string;
    children?: Array<string>;
}

export interface EntryClassesDestroyRequest {
    classSubtype: string;
}

export interface EntryClassesRetrieveRequest {
    classSubtype: string;
}

export interface EntryClassesUpdateRequest {
    classSubtype: string;
    type: EntryClassesUpdateTypeEnum;
    subtype: string;
    format: string | null;
    description?: string | null;
    generativeRegex?: string;
    regex?: string;
    options?: string;
    prefix?: string;
    color?: string;
    children?: Array<string>;
}

/**
 * 
 */
export class EntriesApi extends runtime.BaseAPI {

    /**
     * Creates a new entity. Only available to admin users.
     * Create entity
     */
    async entitiesCreateRaw(requestParameters: EntitiesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Entity>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling entitiesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['aliases'] != null) {
            formParams.append('aliases', requestParameters['aliases']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }


        let urlPath = `/entries/entities/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityFromJSON(jsonValue));
    }

    /**
     * Creates a new entity. Only available to admin users.
     * Create entity
     */
    async entitiesCreate(requestParameters: EntitiesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Entity> {
        const response = await this.entitiesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an entity. Only available to admin users.
     * Delete entity
     */
    async entitiesDestroyRaw(requestParameters: EntitiesDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling entitiesDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entities/{entity_id}/`;
        urlPath = urlPath.replace(`{${"entity_id"}}`, encodeURIComponent(String(requestParameters['entityId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deletes an entity. Only available to admin users.
     * Delete entity
     */
    async entitiesDestroy(requestParameters: EntitiesDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.entitiesDestroyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of entities. For regular users, returns only entities they have access to. For admin users, returns all entities.
     * List entities
     */
    async entitiesListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EntryResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entities/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntryResponseFromJSON));
    }

    /**
     * Returns a list of entities. For regular users, returns only entities they have access to. For admin users, returns all entities.
     * List entities
     */
    async entitiesList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EntryResponse>> {
        const response = await this.entitiesListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns details of a specific entity. Regular users can only access entities they have permissions for. Admin users can access any entity.
     * Get entity details
     */
    async entitiesRetrieveRaw(requestParameters: EntitiesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Entity>> {
        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling entitiesRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entities/{entity_id}/`;
        urlPath = urlPath.replace(`{${"entity_id"}}`, encodeURIComponent(String(requestParameters['entityId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityFromJSON(jsonValue));
    }

    /**
     * Returns details of a specific entity. Regular users can only access entities they have permissions for. Admin users can access any entity.
     * Get entity details
     */
    async entitiesRetrieve(requestParameters: EntitiesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Entity> {
        const response = await this.entitiesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing entity.
     * Update entity
     */
    async entitiesUpdateRaw(requestParameters: EntitiesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling entitiesUpdate().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling entitiesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['aliases'] != null) {
            formParams.append('aliases', requestParameters['aliases']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }


        let urlPath = `/entries/entities/{entity_id}/`;
        urlPath = urlPath.replace(`{${"entity_id"}}`, encodeURIComponent(String(requestParameters['entityId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing entity.
     * Update entity
     */
    async entitiesUpdate(requestParameters: EntitiesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.entitiesUpdateRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new entry (artifact or entity). Only admins can create entities.
     * Create a new entry
     */
    async entriesEntriesCreateRaw(requestParameters: EntriesEntriesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Entry>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling entriesEntriesCreate().'
            );
        }

        if (requestParameters['subtype'] == null) {
            throw new runtime.RequiredError(
                'subtype',
                'Required parameter "subtype" was null or undefined when calling entriesEntriesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['subtype'] != null) {
            formParams.append('subtype', requestParameters['subtype'] as any);
        }


        let urlPath = `/entries/entries/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntryFromJSON(jsonValue));
    }

    /**
     * Creates a new entry (artifact or entity). Only admins can create entities.
     * Create a new entry
     */
    async entriesEntriesCreate(requestParameters: EntriesEntriesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Entry> {
        const response = await this.entriesEntriesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enrich an entry with a specific enricher
     */
    async entriesEntriesEnrichCreateRaw(requestParameters: EntriesEntriesEnrichCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnricherResponse>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling entriesEntriesEnrichCreate().'
            );
        }

        if (requestParameters['enricher'] == null) {
            throw new runtime.RequiredError(
                'enricher',
                'Required parameter "enricher" was null or undefined when calling entriesEntriesEnrichCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['enricher'] != null) {
            formParams.append('enricher', requestParameters['enricher'] as any);
        }


        let urlPath = `/entries/entries/{entry_id}/enrich/`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnricherResponseFromJSON(jsonValue));
    }

    /**
     * Enrich an entry with a specific enricher
     */
    async entriesEntriesEnrichCreate(requestParameters: EntriesEntriesEnrichCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnricherResponse> {
        const response = await this.entriesEntriesEnrichCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get available enrichers for an entry
     */
    async entriesEntriesEnrichListRaw(requestParameters: EntriesEntriesEnrichListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EnricherList>>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling entriesEntriesEnrichList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entries/{entry_id}/enrich/`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnricherListFromJSON));
    }

    /**
     * Get available enrichers for an entry
     */
    async entriesEntriesEnrichList(requestParameters: EntriesEntriesEnrichListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EnricherList>> {
        const response = await this.entriesEntriesEnrichListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns detailed information about a specific entry by ID. Access control applies for entities.
     * Retrieve entry details
     */
    async entriesEntriesRetrieveRaw(requestParameters: EntriesEntriesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Entry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling entriesEntriesRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = await this.configuration.apiKey("Api-Key"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entries/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntryFromJSON(jsonValue));
    }

    /**
     * Returns detailed information about a specific entry by ID. Access control applies for entities.
     * Retrieve entry details
     */
    async entriesEntriesRetrieve(requestParameters: EntriesEntriesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Entry> {
        const response = await this.entriesEntriesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the next available name for entries of this class based on the class prefix and existing entries.
     * Get next available name
     */
    async entriesNextNameRetrieveRaw(requestParameters: EntriesNextNameRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextNameResponse>> {
        if (requestParameters['classSubtype'] == null) {
            throw new runtime.RequiredError(
                'classSubtype',
                'Required parameter "classSubtype" was null or undefined when calling entriesNextNameRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/next_name/{class_subtype}/`;
        urlPath = urlPath.replace(`{${"class_subtype"}}`, encodeURIComponent(String(requestParameters['classSubtype'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextNameResponseFromJSON(jsonValue));
    }

    /**
     * Returns the next available name for entries of this class based on the class prefix and existing entries.
     * Get next available name
     */
    async entriesNextNameRetrieve(requestParameters: EntriesNextNameRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextNameResponse> {
        const response = await this.entriesNextNameRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a specific relation by ID. Only admin users can perform this action.
     * Delete a relation
     */
    async entriesRelationsDestroyRaw(requestParameters: EntriesRelationsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['relationId'] == null) {
            throw new runtime.RequiredError(
                'relationId',
                'Required parameter "relationId" was null or undefined when calling entriesRelationsDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/relations/{relation_id}/`;
        urlPath = urlPath.replace(`{${"relation_id"}}`, encodeURIComponent(String(requestParameters['relationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deletes a specific relation by ID. Only admin users can perform this action.
     * Delete a relation
     */
    async entriesRelationsDestroy(requestParameters: EntriesRelationsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.entriesRelationsDestroyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a paginated list of relations between specified entries.Requires \'relates\' query parameter with entry IDs.
     * List relations between entries
     */
    async entriesRelationsRetrieveRaw(requestParameters: EntriesRelationsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedRelationSerializerResponse>> {
        if (requestParameters['relates'] == null) {
            throw new runtime.RequiredError(
                'relates',
                'Required parameter "relates" was null or undefined when calling entriesRelationsRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['relates'] != null) {
            queryParameters['relates'] = requestParameters['relates'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/relations/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRelationSerializerResponseFromJSON(jsonValue));
    }

    /**
     * Returns a paginated list of relations between specified entries.Requires \'relates\' query parameter with entry IDs.
     * List relations between entries
     */
    async entriesRelationsRetrieve(requestParameters: EntriesRelationsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedRelationSerializerResponse> {
        const response = await this.entriesRelationsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new entry class. Only available to admin users.
     * Create entry class
     */
    async entryClassesCreateRaw(requestParameters: EntryClassesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntryClass>> {
        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling entryClassesCreate().'
            );
        }

        if (requestParameters['subtype'] == null) {
            throw new runtime.RequiredError(
                'subtype',
                'Required parameter "subtype" was null or undefined when calling entryClassesCreate().'
            );
        }

        if (requestParameters['format'] == null) {
            throw new runtime.RequiredError(
                'format',
                'Required parameter "format" was null or undefined when calling entryClassesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['type'] != null) {
            formParams.append('type', requestParameters['type'] as any);
        }

        if (requestParameters['subtype'] != null) {
            formParams.append('subtype', requestParameters['subtype'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['generativeRegex'] != null) {
            formParams.append('generative_regex', requestParameters['generativeRegex'] as any);
        }

        if (requestParameters['regex'] != null) {
            formParams.append('regex', requestParameters['regex'] as any);
        }

        if (requestParameters['options'] != null) {
            formParams.append('options', requestParameters['options'] as any);
        }

        if (requestParameters['prefix'] != null) {
            formParams.append('prefix', requestParameters['prefix'] as any);
        }

        if (requestParameters['color'] != null) {
            formParams.append('color', requestParameters['color'] as any);
        }

        if (requestParameters['children'] != null) {
            formParams.append('children', requestParameters['children']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['format'] != null) {
            formParams.append('format', requestParameters['format'] as any);
        }


        let urlPath = `/entries/entry_classes/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntryClassFromJSON(jsonValue));
    }

    /**
     * Creates a new entry class. Only available to admin users.
     * Create entry class
     */
    async entryClassesCreate(requestParameters: EntryClassesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntryClass> {
        const response = await this.entryClassesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an entry class. Only available to admin users. Cannot delete the \'alias\' entry class.
     * Delete entry class
     */
    async entryClassesDestroyRaw(requestParameters: EntryClassesDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['classSubtype'] == null) {
            throw new runtime.RequiredError(
                'classSubtype',
                'Required parameter "classSubtype" was null or undefined when calling entryClassesDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entry_classes/{class_subtype}/`;
        urlPath = urlPath.replace(`{${"class_subtype"}}`, encodeURIComponent(String(requestParameters['classSubtype'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deletes an entry class. Only available to admin users. Cannot delete the \'alias\' entry class.
     * Delete entry class
     */
    async entryClassesDestroy(requestParameters: EntryClassesDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.entryClassesDestroyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all entry classes.
     * List Entry Classes
     */
    async entryClassesListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EntryClass>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entry_classes/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntryClassFromJSON));
    }

    /**
     * Retrieve a list of all entry classes.
     * List Entry Classes
     */
    async entryClassesList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EntryClass>> {
        const response = await this.entryClassesListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns details of a specific entry class.
     * Get entry class details
     */
    async entryClassesRetrieveRaw(requestParameters: EntryClassesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntryClass>> {
        if (requestParameters['classSubtype'] == null) {
            throw new runtime.RequiredError(
                'classSubtype',
                'Required parameter "classSubtype" was null or undefined when calling entryClassesRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/entries/entry_classes/{class_subtype}/`;
        urlPath = urlPath.replace(`{${"class_subtype"}}`, encodeURIComponent(String(requestParameters['classSubtype'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntryClassFromJSON(jsonValue));
    }

    /**
     * Returns details of a specific entry class.
     * Get entry class details
     */
    async entryClassesRetrieve(requestParameters: EntryClassesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntryClass> {
        const response = await this.entryClassesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing entry class. Cannot edit the \'alias\' entry class.
     * Update entry class
     */
    async entryClassesUpdateRaw(requestParameters: EntryClassesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntryClass>> {
        if (requestParameters['classSubtype'] == null) {
            throw new runtime.RequiredError(
                'classSubtype',
                'Required parameter "classSubtype" was null or undefined when calling entryClassesUpdate().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling entryClassesUpdate().'
            );
        }

        if (requestParameters['subtype'] == null) {
            throw new runtime.RequiredError(
                'subtype',
                'Required parameter "subtype" was null or undefined when calling entryClassesUpdate().'
            );
        }

        if (requestParameters['format'] == null) {
            throw new runtime.RequiredError(
                'format',
                'Required parameter "format" was null or undefined when calling entryClassesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwtAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['type'] != null) {
            formParams.append('type', requestParameters['type'] as any);
        }

        if (requestParameters['subtype'] != null) {
            formParams.append('subtype', requestParameters['subtype'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['generativeRegex'] != null) {
            formParams.append('generative_regex', requestParameters['generativeRegex'] as any);
        }

        if (requestParameters['regex'] != null) {
            formParams.append('regex', requestParameters['regex'] as any);
        }

        if (requestParameters['options'] != null) {
            formParams.append('options', requestParameters['options'] as any);
        }

        if (requestParameters['prefix'] != null) {
            formParams.append('prefix', requestParameters['prefix'] as any);
        }

        if (requestParameters['color'] != null) {
            formParams.append('color', requestParameters['color'] as any);
        }

        if (requestParameters['children'] != null) {
            formParams.append('children', requestParameters['children']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['format'] != null) {
            formParams.append('format', requestParameters['format'] as any);
        }


        let urlPath = `/entries/entry_classes/{class_subtype}/`;
        urlPath = urlPath.replace(`{${"class_subtype"}}`, encodeURIComponent(String(requestParameters['classSubtype'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntryClassFromJSON(jsonValue));
    }

    /**
     * Updates an existing entry class. Cannot edit the \'alias\' entry class.
     * Update entry class
     */
    async entryClassesUpdate(requestParameters: EntryClassesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntryClass> {
        const response = await this.entryClassesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const EntryClassesCreateTypeEnum = {
    Entity: 'entity',
    Artifact: 'artifact'
} as const;
export type EntryClassesCreateTypeEnum = typeof EntryClassesCreateTypeEnum[keyof typeof EntryClassesCreateTypeEnum];
/**
 * @export
 */
export const EntryClassesUpdateTypeEnum = {
    Entity: 'entity',
    Artifact: 'artifact'
} as const;
export type EntryClassesUpdateTypeEnum = typeof EntryClassesUpdateTypeEnum[keyof typeof EntryClassesUpdateTypeEnum];
